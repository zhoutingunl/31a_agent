# 最佳实践指南

## 概述

本文档介绍Agent智能体系统开发的最佳实践，包括代码规范、性能优化、安全实践、测试策略等方面。

## 代码规范

### 1. Python代码规范

#### 命名规范

```python
# 类名使用大驼峰命名
class MemoryManager:
    pass

class KnowledgeGraphManager:
    pass

# 函数和变量名使用小写下划线
def get_memory_by_id(memory_id: str) -> MemoryItem:
    user_name = "张三"
    memory_type = "long_term"
    return memory_item

# 常量使用大写下划线
MAX_MEMORY_SIZE = 1000
DEFAULT_TIMEOUT = 30

# 私有方法使用下划线前缀
class MemoryManager:
    def _validate_memory(self, memory: MemoryItem) -> bool:
        pass
    
    def __private_method(self):
        pass
```

#### 类型注解

```python
from typing import List, Dict, Optional, Union, Any
from datetime import datetime

def process_memories(
    memories: List[MemoryItem],
    filters: Optional[Dict[str, Any]] = None,
    limit: int = 10
) -> List[MemoryItem]:
    """处理记忆列表"""
    pass

async def store_memory(
    content: str,
    memory_type: MemoryType,
    user_id: int
) -> str:
    """存储记忆"""
    pass
```

#### 文档字符串

```python
class MemoryManager:
    """记忆管理器
    
    负责管理用户的短期、长期记忆和知识图谱。
    支持记忆的存储、检索、压缩和遗忘。
    """
    
    def store_memory(
        self,
        content: str,
        memory_type: MemoryType,
        importance_score: float,
        metadata: Dict[str, Any],
        user_id: int
    ) -> str:
        """存储记忆
        
        Args:
            content: 记忆内容
            memory_type: 记忆类型 (SHORT_TERM, LONG_TERM, KNOWLEDGE_GRAPH)
            importance_score: 重要性评分 (0-10)
            metadata: 元数据信息
            user_id: 用户ID
            
        Returns:
            str: 记忆ID
            
        Raises:
            ValidationError: 当参数验证失败时
            StorageError: 当存储失败时
            
        Example:
            >>> manager = MemoryManager()
            >>> memory_id = await manager.store_memory(
            ...     content="用户喜欢Python编程",
            ...     memory_type=MemoryType.LONG_TERM,
            ...     importance_score=8.5,
            ...     metadata={"source": "conversation"},
            ...     user_id=1
            ... )
        """
        pass
```

### 2. 项目结构规范

```
app/
├── __init__.py
├── main.py                 # 应用入口
├── config/                 # 配置文件
│   ├── __init__.py
│   ├── settings.py
│   └── database.py
├── core/                   # 核心模块
│   ├── __init__.py
│   ├── orchestrator/       # 编排器
│   ├── memory/            # 记忆系统
│   ├── knowledge/         # 知识图谱
│   └── planning/          # 任务规划
├── services/              # 服务层
│   ├── __init__.py
│   ├── memory_service.py
│   ├── knowledge_service.py
│   └── role_service.py
├── models/                # 数据模型
│   ├── __init__.py
│   ├── database.py
│   ├── memory.py
│   └── knowledge.py
├── schemas/               # Pydantic模型
│   ├── __init__.py
│   ├── memory.py
│   └── knowledge.py
├── api/                   # API接口
│   ├── __init__.py
│   └── v1/
│       ├── __init__.py
│       ├── chat.py
│       └── memory.py
├── tools/                 # 工具模块
│   ├── __init__.py
│   ├── base.py
│   └── database_tool.py
├── utils/                 # 工具函数
│   ├── __init__.py
│   ├── logger.py
│   └── exceptions.py
└── tests/                 # 测试文件
    ├── __init__.py
    ├── unit/
    ├── integration/
    └── e2e/
```

### 3. 配置管理

```python
# config/settings.py
from pydantic import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """应用配置"""
    
    # 应用配置
    app_name: str = "Agent智能体系统"
    app_version: str = "1.0.0"
    debug: bool = False
    
    # 数据库配置
    database_url: str
    database_pool_size: int = 20
    database_max_overflow: int = 30
    
    # Redis配置
    redis_url: str = "redis://localhost:6379"
    redis_max_connections: int = 100
    
    # LLM配置
    deepseek_api_key: str
    deepseek_base_url: str = "https://api.deepseek.com"
    llm_timeout: int = 30
    
    # 记忆系统配置
    max_short_term_memories: int = 100
    max_long_term_memories: int = 1000
    importance_threshold: float = 7.0
    
    # 安全配置
    jwt_secret: str
    jwt_expire_hours: int = 24
    rate_limit_requests: int = 100
    rate_limit_window: int = 3600
    
    class Config:
        env_file = ".env"
        case_sensitive = False

# 全局配置实例
settings = Settings()
```

## 性能优化

### 1. 数据库优化

#### 连接池配置

```python
# config/database.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

def create_database_engine(database_url: str) -> Engine:
    """创建数据库引擎"""
    engine = create_engine(
        database_url,
        poolclass=QueuePool,
        pool_size=20,  # 连接池大小
        max_overflow=30,  # 最大溢出连接数
        pool_pre_ping=True,  # 连接前ping检查
        pool_recycle=3600,  # 连接回收时间
        echo=False  # 生产环境关闭SQL日志
    )
    return engine
```

#### 查询优化

```python
# 使用索引
class MemoryDAO:
    async def get_memories_by_user(
        self,
        user_id: int,
        memory_type: Optional[MemoryType] = None,
        limit: int = 10,
        offset: int = 0
    ) -> List[MemoryItem]:
        """获取用户记忆（优化查询）"""
        query = self.db.query(MemoryItem).filter(
            MemoryItem.user_id == user_id
        )
        
        if memory_type:
            query = query.filter(MemoryItem.memory_type == memory_type)
        
        # 使用索引排序
        query = query.order_by(MemoryItem.importance_score.desc())
        
        # 分页查询
        return query.offset(offset).limit(limit).all()

# 批量操作
async def batch_create_memories(
    self,
    memories: List[Dict[str, Any]]
) -> List[str]:
    """批量创建记忆"""
    try:
        # 使用bulk_insert_mappings提高性能
        self.db.bulk_insert_mappings(MemoryItem, memories)
        self.db.commit()
        return [memory["id"] for memory in memories]
    except Exception as e:
        self.db.rollback()
        raise
```

#### 缓存策略

```python
# utils/cache.py
import redis
import json
from typing import Any, Optional
from functools import wraps

class CacheManager:
    """缓存管理器"""
    
    def __init__(self, redis_url: str):
        self.redis_client = redis.from_url(redis_url)
        self.default_ttl = 3600  # 默认1小时
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        try:
            value = await self.redis_client.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            logger.error(f"缓存获取失败: {e}")
            return None
    
    async def set(self, key: str, value: Any, ttl: int = None) -> bool:
        """设置缓存"""
        try:
            ttl = ttl or self.default_ttl
            await self.redis_client.setex(
                key, ttl, json.dumps(value, ensure_ascii=False)
            )
            return True
        except Exception as e:
            logger.error(f"缓存设置失败: {e}")
            return False

def cache_result(ttl: int = 3600):
    """缓存结果装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cached_result = await cache_manager.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            await cache_manager.set(cache_key, result, ttl)
            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(ttl=1800)  # 缓存30分钟
async def get_user_memories(user_id: int) -> List[MemoryItem]:
    """获取用户记忆（带缓存）"""
    pass
```

### 2. 异步处理优化

```python
# utils/async_utils.py
import asyncio
from typing import List, Callable, Any
from concurrent.futures import ThreadPoolExecutor

class AsyncTaskManager:
    """异步任务管理器"""
    
    def __init__(self, max_workers: int = 10):
        self.semaphore = asyncio.Semaphore(max_workers)
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def run_in_executor(self, func: Callable, *args) -> Any:
        """在线程池中运行函数"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self.executor, func, *args)
    
    async def gather_with_semaphore(self, tasks: List[Callable]) -> List[Any]:
        """使用信号量限制并发数"""
        async def limited_task(task):
            async with self.semaphore:
                return await task()
        
        return await asyncio.gather(*[limited_task(task) for task in tasks])

# 使用示例
async def process_memories_batch(memories: List[MemoryItem]) -> List[ProcessedMemory]:
    """批量处理记忆"""
    task_manager = AsyncTaskManager(max_workers=5)
    
    async def process_single_memory(memory: MemoryItem) -> ProcessedMemory:
        # 模拟处理逻辑
        await asyncio.sleep(0.1)
        return ProcessedMemory.from_memory(memory)
    
    tasks = [lambda m=memory: process_single_memory(m) for memory in memories]
    return await task_manager.gather_with_semaphore(tasks)
```

### 3. 内存优化

```python
# utils/memory_optimization.py
import gc
import psutil
from typing import Generator, Any

class MemoryOptimizer:
    """内存优化器"""
    
    @staticmethod
    def get_memory_usage() -> float:
        """获取当前内存使用量（MB）"""
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024
    
    @staticmethod
    def force_garbage_collection():
        """强制垃圾回收"""
        gc.collect()
    
    @staticmethod
    def process_large_dataset(data: List[Any], batch_size: int = 1000) -> Generator[List[Any], None, None]:
        """分批处理大数据集"""
        for i in range(0, len(data), batch_size):
            yield data[i:i + batch_size]
            # 每批处理后进行垃圾回收
            gc.collect()

# 使用示例
async def process_large_memory_dataset(memories: List[MemoryItem]) -> List[ProcessedMemory]:
    """处理大量记忆数据"""
    optimizer = MemoryOptimizer()
    processed_memories = []
    
    for batch in optimizer.process_large_dataset(memories, batch_size=500):
        batch_results = await process_memory_batch(batch)
        processed_memories.extend(batch_results)
        
        # 记录内存使用情况
        memory_usage = optimizer.get_memory_usage()
        logger.info(f"当前内存使用: {memory_usage:.2f} MB")
        
        # 如果内存使用过高，强制垃圾回收
        if memory_usage > 1000:  # 超过1GB
            optimizer.force_garbage_collection()
    
    return processed_memories
```

## 安全实践

### 1. 输入验证

```python
# utils/validation.py
import re
from typing import Any, Dict, List
from pydantic import BaseModel, validator, Field

class InputValidator:
    """输入验证器"""
    
    @staticmethod
    def validate_content(content: str) -> bool:
        """验证内容"""
        # 长度检查
        if len(content) > 10000:
            return False
        
        # 空内容检查
        if not content.strip():
            return False
        
        # 恶意内容检查
        malicious_patterns = [
            r"<script.*?>.*?</script>",  # XSS
            r"javascript:",  # JavaScript协议
            r"on\w+\s*=",  # 事件处理器
            r"eval\s*\(",  # eval函数
            r"expression\s*\(",  # CSS表达式
        ]
        
        for pattern in malicious_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return False
        
        return True
    
    @staticmethod
    def sanitize_content(content: str) -> str:
        """清理内容"""
        # 移除HTML标签
        content = re.sub(r'<[^>]+>', '', content)
        
        # 转义特殊字符
        content = content.replace('&', '&amp;')
        content = content.replace('<', '&lt;')
        content = content.replace('>', '&gt;')
        content = content.replace('"', '&quot;')
        content = content.replace("'", '&#x27;')
        
        return content

# Pydantic模型验证
class MessageRequest(BaseModel):
    """消息请求模型"""
    user_id: int = Field(..., gt=0, description="用户ID必须为正整数")
    content: str = Field(..., min_length=1, max_length=10000, description="消息内容")
    
    @validator('content')
    def validate_content(cls, v):
        if not InputValidator.validate_content(v):
            raise ValueError('内容包含非法字符或格式')
        return InputValidator.sanitize_content(v)
    
    @validator('user_id')
    def validate_user_id(cls, v):
        if v <= 0:
            raise ValueError('用户ID必须为正整数')
        return v
```

### 2. 认证授权

```python
# utils/auth.py
import jwt
import hashlib
import secrets
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, status

class AuthManager:
    """认证管理器"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
        self.token_blacklist = set()
    
    def create_access_token(
        self,
        user_id: int,
        role: str,
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """创建访问令牌"""
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(hours=24)
        
        payload = {
            "user_id": user_id,
            "role": role,
            "exp": expire,
            "iat": datetime.utcnow(),
            "jti": secrets.token_urlsafe(32)  # JWT ID
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Dict[str, Any]:
        """验证令牌"""
        try:
            # 检查黑名单
            if token in self.token_blacklist:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="令牌已失效"
                )
            
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="令牌已过期"
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="无效令牌"
            )
    
    def blacklist_token(self, token: str):
        """将令牌加入黑名单"""
        self.token_blacklist.add(token)
    
    def hash_password(self, password: str) -> str:
        """哈希密码"""
        salt = secrets.token_hex(16)
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000
        )
        return f"{salt}:{password_hash.hex()}"
    
    def verify_password(self, password: str, hashed_password: str) -> bool:
        """验证密码"""
        try:
            salt, password_hash = hashed_password.split(':')
            new_hash = hashlib.pbkdf2_hmac(
                'sha256',
                password.encode('utf-8'),
                salt.encode('utf-8'),
                100000
            )
            return new_hash.hex() == password_hash
        except ValueError:
            return False
```

### 3. 限流控制

```python
# utils/rate_limiter.py
import time
from typing import Dict, Optional
from collections import defaultdict, deque
from fastapi import HTTPException, status

class RateLimiter:
    """限流器"""
    
    def __init__(self, max_requests: int = 100, window: int = 3600):
        self.max_requests = max_requests
        self.window = window
        self.requests: Dict[int, deque] = defaultdict(deque)
    
    def is_allowed(self, user_id: int, request_time: Optional[float] = None) -> bool:
        """检查是否允许请求"""
        if request_time is None:
            request_time = time.time()
        
        user_requests = self.requests[user_id]
        
        # 清理过期请求
        while user_requests and user_requests[0] <= request_time - self.window:
            user_requests.popleft()
        
        # 检查请求数量
        if len(user_requests) >= self.max_requests:
            return False
        
        # 记录新请求
        user_requests.append(request_time)
        return True
    
    def get_remaining_requests(self, user_id: int) -> int:
        """获取剩余请求数"""
        user_requests = self.requests[user_id]
        current_time = time.time()
        
        # 清理过期请求
        while user_requests and user_requests[0] <= current_time - self.window:
            user_requests.popleft()
        
        return max(0, self.max_requests - len(user_requests))
    
    def get_reset_time(self, user_id: int) -> float:
        """获取重置时间"""
        user_requests = self.requests[user_id]
        if not user_requests:
            return time.time()
        
        return user_requests[0] + self.window

# 使用示例
rate_limiter = RateLimiter(max_requests=100, window=3600)

async def check_rate_limit(user_id: int):
    """检查限流"""
    if not rate_limiter.is_allowed(user_id):
        reset_time = rate_limiter.get_reset_time(user_id)
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "message": "请求过于频繁",
                "reset_time": reset_time,
                "remaining_requests": 0
            }
        )
```

## 测试策略

### 1. 单元测试

```python
# tests/unit/test_memory_manager.py
import pytest
from unittest.mock import Mock, AsyncMock, patch
from app.core.memory.manager import MemoryManager
from app.core.memory.schemas import MemoryType, MemoryItem

class TestMemoryManager:
    """记忆管理器测试"""
    
    @pytest.fixture
    def memory_manager(self):
        """创建记忆管理器实例"""
        return MemoryManager()
    
    @pytest.fixture
    def sample_memory(self):
        """示例记忆数据"""
        return MemoryItem(
            content="测试记忆内容",
            memory_type=MemoryType.SHORT_TERM,
            importance_score=8.0,
            user_id=1
        )
    
    @pytest.mark.asyncio
    async def test_store_memory_success(self, memory_manager, sample_memory):
        """测试成功存储记忆"""
        with patch.object(memory_manager, '_store_to_database') as mock_store:
            mock_store.return_value = "memory_123"
            
            result = await memory_manager.store_memory(
                content=sample_memory.content,
                memory_type=sample_memory.memory_type,
                importance_score=sample_memory.importance_score,
                user_id=sample_memory.user_id
            )
            
            assert result == "memory_123"
            mock_store.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_store_memory_validation_error(self, memory_manager):
        """测试存储记忆验证错误"""
        with pytest.raises(ValueError, match="内容不能为空"):
            await memory_manager.store_memory(
                content="",
                memory_type=MemoryType.SHORT_TERM,
                importance_score=8.0,
                user_id=1
            )
    
    @pytest.mark.asyncio
    async def test_retrieve_memories(self, memory_manager):
        """测试检索记忆"""
        with patch.object(memory_manager, '_search_memories') as mock_search:
            mock_memories = [
                MemoryItem(
                    content="记忆1",
                    memory_type=MemoryType.SHORT_TERM,
                    importance_score=8.0,
                    user_id=1
                ),
                MemoryItem(
                    content="记忆2",
                    memory_type=MemoryType.LONG_TERM,
                    importance_score=9.0,
                    user_id=1
                )
            ]
            mock_search.return_value = mock_memories
            
            result = await memory_manager.retrieve_memories(
                query="测试查询",
                user_id=1,
                limit=10
            )
            
            assert len(result) == 2
            assert result[0].content == "记忆1"
            assert result[1].content == "记忆2"
```

### 2. 集成测试

```python
# tests/integration/test_memory_integration.py
import pytest
from httpx import AsyncClient
from app.main import app
from app.models.database import get_database
from app.core.memory.manager import MemoryManager

class TestMemoryIntegration:
    """记忆系统集成测试"""
    
    @pytest.fixture
    async def client(self):
        """创建测试客户端"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            yield ac
    
    @pytest.fixture
    def db(self):
        """获取数据库会话"""
        return next(get_database())
    
    @pytest.mark.asyncio
    async def test_memory_workflow(self, client, db):
        """测试记忆工作流程"""
        # 1. 创建记忆
        response = await client.post("/api/v1/memories", json={
            "content": "用户喜欢Python编程",
            "memory_type": "long_term",
            "importance_score": 8.5,
            "user_id": 1
        })
        assert response.status_code == 200
        memory_data = response.json()
        memory_id = memory_data["id"]
        
        # 2. 检索记忆
        response = await client.get("/api/v1/memories", params={
            "user_id": 1,
            "query": "Python",
            "limit": 10
        })
        assert response.status_code == 200
        memories = response.json()["memories"]
        assert len(memories) > 0
        assert any("Python" in memory["content"] for memory in memories)
        
        # 3. 更新记忆重要性
        response = await client.put(f"/api/v1/memories/{memory_id}/importance", json={
            "importance_score": 9.0
        })
        assert response.status_code == 200
        
        # 4. 删除记忆
        response = await client.delete(f"/api/v1/memories/{memory_id}")
        assert response.status_code == 200
```

### 3. 性能测试

```python
# tests/performance/test_memory_performance.py
import pytest
import time
import asyncio
from app.core.memory.manager import MemoryManager

class TestMemoryPerformance:
    """记忆系统性能测试"""
    
    @pytest.fixture
    def memory_manager(self):
        return MemoryManager()
    
    @pytest.mark.asyncio
    async def test_memory_storage_performance(self, memory_manager):
        """测试记忆存储性能"""
        start_time = time.time()
        
        # 批量存储记忆
        tasks = []
        for i in range(100):
            task = memory_manager.store_memory(
                content=f"测试记忆 {i}",
                memory_type=MemoryType.SHORT_TERM,
                importance_score=7.0,
                user_id=1
            )
            tasks.append(task)
        
        await asyncio.gather(*tasks)
        
        end_time = time.time()
        duration = end_time - start_time
        
        # 性能断言
        assert duration < 10.0  # 100个记忆存储应在10秒内完成
        print(f"存储100个记忆耗时: {duration:.2f}秒")
    
    @pytest.mark.asyncio
    async def test_memory_retrieval_performance(self, memory_manager):
        """测试记忆检索性能"""
        # 先存储一些记忆
        for i in range(50):
            await memory_manager.store_memory(
                content=f"Python编程记忆 {i}",
                memory_type=MemoryType.LONG_TERM,
                importance_score=8.0,
                user_id=1
            )
        
        start_time = time.time()
        
        # 测试检索性能
        result = await memory_manager.retrieve_memories(
            query="Python",
            user_id=1,
            limit=20
        )
        
        end_time = time.time()
        duration = end_time - start_time
        
        # 性能断言
        assert duration < 2.0  # 检索应在2秒内完成
        assert len(result) > 0
        print(f"检索记忆耗时: {duration:.2f}秒")
```

## 错误处理

### 1. 异常定义

```python
# utils/exceptions.py
class AgentException(Exception):
    """Agent系统基础异常"""
    
    def __init__(self, message: str, error_code: str = None, details: Dict[str, Any] = None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)

class ValidationError(AgentException):
    """验证错误"""
    pass

class StorageError(AgentException):
    """存储错误"""
    pass

class LLMError(AgentException):
    """LLM调用错误"""
    pass

class MemoryError(AgentException):
    """记忆系统错误"""
    pass

class KnowledgeGraphError(AgentException):
    """知识图谱错误"""
    pass
```

### 2. 错误处理中间件

```python
# middleware/error_handler.py
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from app.utils.exceptions import AgentException
from app.utils.logger import get_logger

logger = get_logger(__name__)

async def error_handler_middleware(request: Request, call_next):
    """错误处理中间件"""
    try:
        response = await call_next(request)
        return response
    except AgentException as e:
        logger.error(f"Agent异常: {e.message}", extra={
            "error_code": e.error_code,
            "details": e.details
        })
        
        return JSONResponse(
            status_code=400,
            content={
                "success": False,
                "error": {
                    "code": e.error_code or "AGENT_ERROR",
                    "message": e.message,
                    "details": e.details
                }
            }
        )
    except HTTPException as e:
        return JSONResponse(
            status_code=e.status_code,
            content={
                "success": False,
                "error": {
                    "code": "HTTP_ERROR",
                    "message": e.detail
                }
            }
        )
    except Exception as e:
        logger.error(f"未处理的异常: {str(e)}", exc_info=True)
        
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "error": {
                    "code": "INTERNAL_ERROR",
                    "message": "内部服务器错误"
                }
            }
        )
```

### 3. 重试机制

```python
# utils/retry.py
import asyncio
import random
from typing import Callable, Any, Optional
from functools import wraps

def retry_on_failure(
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    exponential_base: float = 2.0,
    jitter: bool = True
):
    """重试装饰器"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            last_exception = None
            
            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    
                    if attempt == max_retries:
                        break
                    
                    # 计算延迟时间
                    delay = min(
                        base_delay * (exponential_base ** attempt),
                        max_delay
                    )
                    
                    # 添加抖动
                    if jitter:
                        delay *= (0.5 + random.random() * 0.5)
                    
                    logger.warning(
                        f"第{attempt + 1}次尝试失败: {str(e)}, "
                        f"{delay:.2f}秒后重试"
                    )
                    
                    await asyncio.sleep(delay)
            
            # 所有重试都失败
            logger.error(f"重试{max_retries}次后仍然失败: {str(last_exception)}")
            raise last_exception
        
        return wrapper
    return decorator

# 使用示例
@retry_on_failure(max_retries=3, base_delay=1.0)
async def call_llm_api(prompt: str) -> str:
    """调用LLM API（带重试）"""
    # LLM API调用逻辑
    pass
```

## 日志记录

### 1. 日志配置

```python
# utils/logger.py
import logging
import sys
from typing import Dict, Any
from datetime import datetime

class StructuredLogger:
    """结构化日志记录器"""
    
    def __init__(self, name: str, level: str = "INFO"):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(getattr(logging, level.upper()))
        
        # 创建格式化器
        formatter = logging.Formatter(
            '%(asctime)s | %(levelname)s | %(name)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # 控制台处理器
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)
        
        # 文件处理器
        file_handler = logging.FileHandler('logs/app.log')
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
    
    def _format_message(self, message: str, extra: Dict[str, Any] = None) -> str:
        """格式化消息"""
        if extra:
            extra_str = " | ".join([f"{k}={v}" for k, v in extra.items()])
            return f"{message} | {extra_str}"
        return message
    
    def info(self, message: str, extra: Dict[str, Any] = None):
        """记录信息日志"""
        self.logger.info(self._format_message(message, extra))
    
    def warning(self, message: str, extra: Dict[str, Any] = None):
        """记录警告日志"""
        self.logger.warning(self._format_message(message, extra))
    
    def error(self, message: str, extra: Dict[str, Any] = None):
        """记录错误日志"""
        self.logger.error(self._format_message(message, extra))
    
    def debug(self, message: str, extra: Dict[str, Any] = None):
        """记录调试日志"""
        self.logger.debug(self._format_message(message, extra))

# 全局日志记录器
def get_logger(name: str) -> StructuredLogger:
    """获取日志记录器"""
    return StructuredLogger(name)

# 使用示例
logger = get_logger(__name__)

logger.info("用户登录", extra={"user_id": 123, "ip": "192.168.1.1"})
logger.error("数据库连接失败", extra={"error": "Connection timeout"})
```

### 2. 性能监控

```python
# utils/monitoring.py
import time
import psutil
from typing import Dict, Any
from functools import wraps

class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self):
        self.metrics = {}
    
    def record_execution_time(self, operation: str, duration: float):
        """记录执行时间"""
        if operation not in self.metrics:
            self.metrics[operation] = []
        self.metrics[operation].append(duration)
    
    def get_metrics(self) -> Dict[str, Any]:
        """获取性能指标"""
        result = {}
        for operation, times in self.metrics.items():
            if times:
                result[operation] = {
                    "count": len(times),
                    "avg_time": sum(times) / len(times),
                    "max_time": max(times),
                    "min_time": min(times)
                }
        return result
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """获取系统指标"""
        return {
            "cpu_percent": psutil.cpu_percent(),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent
        }

# 性能监控装饰器
def monitor_performance(operation_name: str):
    """性能监控装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                return result
            finally:
                duration = time.time() - start_time
                monitor.record_execution_time(operation_name, duration)
        return wrapper
    return decorator

# 全局监控器
monitor = PerformanceMonitor()

# 使用示例
@monitor_performance("memory_storage")
async def store_memory(content: str) -> str:
    """存储记忆（带性能监控）"""
    # 存储逻辑
    pass
```

## 总结

本最佳实践指南涵盖了Agent智能体系统开发的关键方面：

1. **代码规范**: 命名规范、类型注解、文档字符串
2. **性能优化**: 数据库优化、异步处理、内存优化
3. **安全实践**: 输入验证、认证授权、限流控制
4. **测试策略**: 单元测试、集成测试、性能测试
5. **错误处理**: 异常定义、错误处理中间件、重试机制
6. **日志记录**: 结构化日志、性能监控

遵循这些最佳实践可以确保代码质量、系统性能和安全性，为Agent智能体系统的稳定运行提供保障。
