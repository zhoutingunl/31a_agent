# 扩展开发指南

## 概述

本指南介绍如何扩展Agent智能体系统，包括添加新角色、新工具、新记忆策略等。

## 目录结构

```
app/
├── core/                    # 核心模块
│   ├── orchestrator/        # 编排器
│   ├── memory/             # 记忆系统
│   ├── knowledge/          # 知识图谱
│   └── planning/           # 任务规划
├── services/               # 服务层
├── tools/                  # 工具模块
├── roles/                  # 角色配置
└── api/                    # API接口
```

## 添加新角色

### 1. 创建角色配置文件

在 `app/roles/` 目录下创建新的YAML配置文件：

```yaml
# app/roles/technical_support.yaml
name: "技术支持"
description: "专业的技术支持助手，处理技术问题和故障排除"
system_prompt: |
  你是一个专业的技术支持助手。你的职责是：
  1. 帮助用户解决技术问题
  2. 提供故障排除指导
  3. 解释技术概念
  4. 提供最佳实践建议
  
  请保持专业、耐心和准确。

capabilities:
  - "故障排除"
  - "技术咨询"
  - "系统诊断"
  - "性能优化"

memory_strategy:
  type: "hybrid"
  short_term_enabled: true
  long_term_enabled: true
  knowledge_graph_enabled: true
  user_isolation: true
  rag_enabled: true

tool_permissions:
  allowed:
    - "system_info"
    - "log_analysis"
    - "performance_monitor"
    - "database_query"
  denied:
    - "file_delete"
    - "system_shutdown"

api_endpoints:
  - "/api/v1/technical_support/chat"
  - "/api/v1/technical_support/info"
```

### 2. 创建角色API接口

```python
# app/api/v1/technical_support.py
from fastapi import APIRouter, Depends
from app.schemas.message import MessageSend, ChatResponse
from app.services.role_service import RoleService
from app.core.role.role_manager import RoleManager

router = APIRouter()

@router.post("/chat", response_model=ChatResponse)
async def technical_support_chat(
    request: MessageSend,
    role_service: RoleService = Depends(lambda: RoleService("technical_support"))
):
    """
    技术支持聊天接口
    """
    return await role_service.chat(request)

@router.get("/info")
async def get_technical_support_info():
    """
    获取技术支持角色信息
    """
    role_manager = RoleManager()
    role_config = role_manager.get_role_config("technical_support")
    
    return {
        "role_name": role_config.name,
        "description": role_config.description,
        "capabilities": role_config.capabilities,
        "memory_strategy": role_config.memory_strategy.type,
        "tool_permissions": role_config.tool_permissions.allowed
    }
```

### 3. 注册路由

在 `app/api/v1/__init__.py` 中注册新路由：

```python
from .technical_support import router as technical_support_router

# 注册路由
app.include_router(
    technical_support_router,
    prefix="/api/v1/technical_support",
    tags=["technical_support"]
)
```

### 4. 测试新角色

```python
# tests/test_technical_support.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_technical_support_chat():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/api/v1/technical_support/chat", json={
            "user_id": 1,
            "content": "我的系统运行很慢，请帮我诊断一下"
        })
        assert response.status_code == 200
        data = response.json()
        assert "content" in data
        assert len(data["content"]) > 0

@pytest.mark.asyncio
async def test_technical_support_info():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/api/v1/technical_support/info")
        assert response.status_code == 200
        data = response.json()
        assert data["role_name"] == "技术支持"
```

## 添加新工具

### 1. 创建工具类

```python
# app/tools/system_tools.py
from typing import Dict, Any, List
from app.tools.base import BaseTool
from app.utils.logger import get_logger

logger = get_logger(__name__)

class SystemInfoTool(BaseTool):
    """系统信息查询工具"""
    
    name = "system_info"
    description = "获取系统信息，包括CPU、内存、磁盘使用情况"
    
    def __init__(self):
        super().__init__()
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """
        执行系统信息查询
        
        Returns:
            Dict[str, Any]: 系统信息
        """
        try:
            import psutil
            
            # 获取系统信息
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            return {
                "success": True,
                "data": {
                    "cpu_usage": f"{cpu_percent}%",
                    "memory_usage": f"{memory.percent}%",
                    "memory_available": f"{memory.available / (1024**3):.2f} GB",
                    "disk_usage": f"{disk.percent}%",
                    "disk_free": f"{disk.free / (1024**3):.2f} GB"
                }
            }
        except Exception as e:
            logger.error(f"获取系统信息失败: {e}")
            return {
                "success": False,
                "error": str(e)
            }

class LogAnalysisTool(BaseTool):
    """日志分析工具"""
    
    name = "log_analysis"
    description = "分析系统日志，查找错误和异常"
    
    def __init__(self):
        super().__init__()
    
    async def execute(self, log_path: str = "/var/log/syslog", lines: int = 100, **kwargs) -> Dict[str, Any]:
        """
        分析日志文件
        
        Args:
            log_path: 日志文件路径
            lines: 分析的行数
            
        Returns:
            Dict[str, Any]: 分析结果
        """
        try:
            import subprocess
            
            # 获取最近的日志
            result = subprocess.run(
                ["tail", "-n", str(lines), log_path],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "success": False,
                    "error": f"读取日志失败: {result.stderr}"
                }
            
            log_content = result.stdout
            
            # 简单的错误分析
            error_count = log_content.lower().count("error")
            warning_count = log_content.lower().count("warning")
            
            return {
                "success": True,
                "data": {
                    "log_path": log_path,
                    "lines_analyzed": lines,
                    "error_count": error_count,
                    "warning_count": warning_count,
                    "recent_errors": [
                        line.strip() for line in log_content.split('\n') 
                        if 'error' in line.lower()
                    ][-5:]  # 最近5个错误
                }
            }
        except Exception as e:
            logger.error(f"日志分析失败: {e}")
            return {
                "success": False,
                "error": str(e)
            }
```

### 2. 注册工具

在 `app/tools/manager.py` 中注册新工具：

```python
from app.tools.system_tools import SystemInfoTool, LogAnalysisTool

class ToolManager:
    def __init__(self):
        self.tools = {}
        self._register_default_tools()
    
    def _register_default_tools(self):
        """注册默认工具"""
        # 现有工具...
        
        # 注册新工具
        self.register_tool(SystemInfoTool())
        self.register_tool(LogAnalysisTool())
```

### 3. 测试新工具

```python
# tests/test_system_tools.py
import pytest
from app.tools.system_tools import SystemInfoTool, LogAnalysisTool

@pytest.mark.asyncio
async def test_system_info_tool():
    tool = SystemInfoTool()
    result = await tool.execute()
    
    assert result["success"] is True
    assert "cpu_usage" in result["data"]
    assert "memory_usage" in result["data"]

@pytest.mark.asyncio
async def test_log_analysis_tool():
    tool = LogAnalysisTool()
    result = await tool.execute(log_path="/var/log/syslog", lines=50)
    
    assert result["success"] is True
    assert "error_count" in result["data"]
    assert "warning_count" in result["data"]
```

## 添加新记忆策略

### 1. 创建记忆策略类

```python
# app/core/memory/strategies/custom_strategy.py
from typing import Dict, Any, List, Optional
from app.core.memory.strategies.base import BaseMemoryStrategy
from app.core.memory.schemas import MemoryItem, MemoryType
from app.utils.logger import get_logger

logger = get_logger(__name__)

class CustomMemoryStrategy(BaseMemoryStrategy):
    """自定义记忆策略"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.max_short_term = config.get("max_short_term", 100)
        self.max_long_term = config.get("max_long_term", 1000)
        self.importance_threshold = config.get("importance_threshold", 7.0)
    
    async def store_memory(
        self,
        content: str,
        memory_type: MemoryType,
        importance_score: float,
        metadata: Dict[str, Any],
        user_id: int
    ) -> str:
        """
        存储记忆
        
        Args:
            content: 记忆内容
            memory_type: 记忆类型
            importance_score: 重要性评分
            metadata: 元数据
            user_id: 用户ID
            
        Returns:
            str: 记忆ID
        """
        # 自定义存储逻辑
        if memory_type == MemoryType.SHORT_TERM:
            # 短期记忆存储逻辑
            memory_id = await self._store_short_term(content, metadata, user_id)
        elif memory_type == MemoryType.LONG_TERM:
            # 长期记忆存储逻辑
            memory_id = await self._store_long_term(content, metadata, user_id)
        else:
            # 知识图谱存储逻辑
            memory_id = await self._store_knowledge_graph(content, metadata, user_id)
        
        return memory_id
    
    async def retrieve_memories(
        self,
        query: str,
        user_id: int,
        limit: int = 10,
        memory_types: Optional[List[MemoryType]] = None
    ) -> List[MemoryItem]:
        """
        检索记忆
        
        Args:
            query: 查询内容
            user_id: 用户ID
            limit: 返回数量限制
            memory_types: 记忆类型过滤
            
        Returns:
            List[MemoryItem]: 记忆列表
        """
        memories = []
        
        if memory_types is None:
            memory_types = [MemoryType.SHORT_TERM, MemoryType.LONG_TERM, MemoryType.KNOWLEDGE_GRAPH]
        
        for memory_type in memory_types:
            if memory_type == MemoryType.SHORT_TERM:
                short_term_memories = await self._retrieve_short_term(query, user_id, limit)
                memories.extend(short_term_memories)
            elif memory_type == MemoryType.LONG_TERM:
                long_term_memories = await self._retrieve_long_term(query, user_id, limit)
                memories.extend(long_term_memories)
            elif memory_type == MemoryType.KNOWLEDGE_GRAPH:
                kg_memories = await self._retrieve_knowledge_graph(query, user_id, limit)
                memories.extend(kg_memories)
        
        # 按重要性排序
        memories.sort(key=lambda x: x.importance_score, reverse=True)
        
        return memories[:limit]
    
    async def _store_short_term(self, content: str, metadata: Dict[str, Any], user_id: int) -> str:
        """存储短期记忆"""
        # 实现短期记忆存储逻辑
        pass
    
    async def _store_long_term(self, content: str, metadata: Dict[str, Any], user_id: int) -> str:
        """存储长期记忆"""
        # 实现长期记忆存储逻辑
        pass
    
    async def _store_knowledge_graph(self, content: str, metadata: Dict[str, Any], user_id: int) -> str:
        """存储知识图谱"""
        # 实现知识图谱存储逻辑
        pass
    
    async def _retrieve_short_term(self, query: str, user_id: int, limit: int) -> List[MemoryItem]:
        """检索短期记忆"""
        # 实现短期记忆检索逻辑
        pass
    
    async def _retrieve_long_term(self, query: str, user_id: int, limit: int) -> List[MemoryItem]:
        """检索长期记忆"""
        # 实现长期记忆检索逻辑
        pass
    
    async def _retrieve_knowledge_graph(self, query: str, user_id: int, limit: int) -> List[MemoryItem]:
        """检索知识图谱"""
        # 实现知识图谱检索逻辑
        pass
```

### 2. 注册记忆策略

在 `app/core/memory/manager.py` 中注册新策略：

```python
from app.core.memory.strategies.custom_strategy import CustomMemoryStrategy

class MemoryManager:
    def __init__(self):
        self.strategies = {}
        self._register_strategies()
    
    def _register_strategies(self):
        """注册记忆策略"""
        # 现有策略...
        
        # 注册自定义策略
        self.strategies["custom"] = CustomMemoryStrategy({
            "max_short_term": 200,
            "max_long_term": 2000,
            "importance_threshold": 6.0
        })
```

### 3. 配置角色使用新策略

在角色配置文件中指定新策略：

```yaml
# app/roles/custom_role.yaml
memory_strategy:
  type: "custom"
  config:
    max_short_term: 200
    max_long_term: 2000
    importance_threshold: 6.0
```

## 添加新路由规则

### 1. 创建路由规则

```python
# app/core/orchestrator/rules/custom_rules.py
from typing import Dict, Any, Optional
from app.core.orchestrator.schemas import ExecutionMode
from app.core.orchestrator.router import BaseRoutingRule
from app.utils.logger import get_logger

logger = get_logger(__name__)

class CustomRoutingRule(BaseRoutingRule):
    """自定义路由规则"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.keywords = config.get("keywords", [])
        self.complexity_threshold = config.get("complexity_threshold", 0.7)
    
    def should_apply(self, content: str, context: Dict[str, Any]) -> bool:
        """
        判断是否应该应用此规则
        
        Args:
            content: 用户输入内容
            context: 上下文信息
            
        Returns:
            bool: 是否应用此规则
        """
        # 检查关键词
        for keyword in self.keywords:
            if keyword.lower() in content.lower():
                return True
        
        # 检查复杂度
        complexity = self._calculate_complexity(content)
        if complexity > self.complexity_threshold:
            return True
        
        return False
    
    def get_execution_mode(self, content: str, context: Dict[str, Any]) -> ExecutionMode:
        """
        获取执行模式
        
        Args:
            content: 用户输入内容
            context: 上下文信息
            
        Returns:
            ExecutionMode: 执行模式
        """
        # 根据内容特征决定执行模式
        if any(keyword in content.lower() for keyword in ["计划", "规划", "步骤"]):
            return ExecutionMode.PLANNING
        elif any(keyword in content.lower() for keyword in ["代码", "生成", "实现"]):
            return ExecutionMode.REFLECTION
        else:
            return ExecutionMode.SIMPLE
    
    def _calculate_complexity(self, content: str) -> float:
        """
        计算内容复杂度
        
        Args:
            content: 内容
            
        Returns:
            float: 复杂度分数 (0-1)
        """
        # 简单的复杂度计算逻辑
        word_count = len(content.split())
        sentence_count = content.count('.') + content.count('!') + content.count('?')
        
        if sentence_count == 0:
            return 0.0
        
        avg_words_per_sentence = word_count / sentence_count
        
        # 归一化到0-1范围
        complexity = min(avg_words_per_sentence / 20.0, 1.0)
        
        return complexity
```

### 2. 注册路由规则

在 `app/core/orchestrator/router.py` 中注册新规则：

```python
from app.core.orchestrator.rules.custom_rules import CustomRoutingRule

class Router:
    def __init__(self):
        self.rules = []
        self._register_rules()
    
    def _register_rules(self):
        """注册路由规则"""
        # 现有规则...
        
        # 注册自定义规则
        custom_rule = CustomRoutingRule({
            "keywords": ["复杂", "详细", "分析"],
            "complexity_threshold": 0.6
        })
        self.rules.append(custom_rule)
```

## 添加新数据模型

### 1. 创建数据库模型

```python
# app/models/custom.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from app.models.database import Base

class CustomEntity(Base):
    """自定义实体模型"""
    __tablename__ = "custom_entities"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, index=True)
    description = Column(Text)
    entity_type = Column(String(100), nullable=False, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
    
    # 关系
    user = relationship("User", back_populates="custom_entities")
```

### 2. 创建DAO层

```python
# app/dao/custom_dao.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from app.models.custom import CustomEntity
from app.dao.base import BaseDAO
from app.utils.logger import get_logger

logger = get_logger(__name__)

class CustomDAO(BaseDAO[CustomEntity]):
    """自定义实体DAO"""
    
    def __init__(self, db: Session):
        super().__init__(CustomEntity, db)
    
    async def get_by_user_and_type(
        self,
        user_id: int,
        entity_type: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[CustomEntity]:
        """
        根据用户ID和实体类型获取实体列表
        
        Args:
            user_id: 用户ID
            entity_type: 实体类型
            limit: 限制数量
            offset: 偏移量
            
        Returns:
            List[CustomEntity]: 实体列表
        """
        try:
            query = self.db.query(CustomEntity).filter(
                and_(
                    CustomEntity.user_id == user_id,
                    CustomEntity.entity_type == entity_type
                )
            )
            
            return query.offset(offset).limit(limit).all()
        except Exception as e:
            logger.error(f"获取自定义实体失败: {e}")
            return []
    
    async def search_by_name(
        self,
        user_id: int,
        name: str,
        limit: int = 10
    ) -> List[CustomEntity]:
        """
        根据名称搜索实体
        
        Args:
            user_id: 用户ID
            name: 名称关键词
            limit: 限制数量
            
        Returns:
            List[CustomEntity]: 实体列表
        """
        try:
            query = self.db.query(CustomEntity).filter(
                and_(
                    CustomEntity.user_id == user_id,
                    CustomEntity.name.contains(name)
                )
            )
            
            return query.limit(limit).all()
        except Exception as e:
            logger.error(f"搜索自定义实体失败: {e}")
            return []
```

### 3. 创建Pydantic模型

```python
# app/schemas/custom.py
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class CustomEntityBase(BaseModel):
    """自定义实体基础模型"""
    name: str = Field(..., description="实体名称")
    description: Optional[str] = Field(None, description="实体描述")
    entity_type: str = Field(..., description="实体类型")

class CustomEntityCreate(CustomEntityBase):
    """创建自定义实体模型"""
    pass

class CustomEntityUpdate(BaseModel):
    """更新自定义实体模型"""
    name: Optional[str] = Field(None, description="实体名称")
    description: Optional[str] = Field(None, description="实体描述")
    entity_type: Optional[str] = Field(None, description="实体类型")

class CustomEntityResponse(CustomEntityBase):
    """自定义实体响应模型"""
    id: int
    user_id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class CustomEntityListResponse(BaseModel):
    """自定义实体列表响应模型"""
    entities: List[CustomEntityResponse]
    total: int
    page: int
    size: int
```

### 4. 创建服务层

```python
# app/services/custom_service.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from app.dao.custom_dao import CustomDAO
from app.schemas.custom import (
    CustomEntityCreate,
    CustomEntityUpdate,
    CustomEntityResponse,
    CustomEntityListResponse
)
from app.utils.logger import get_logger

logger = get_logger(__name__)

class CustomService:
    """自定义实体服务"""
    
    def __init__(self, db: Session):
        self.db = db
        self.dao = CustomDAO(db)
    
    async def create_entity(
        self,
        entity_data: CustomEntityCreate,
        user_id: int
    ) -> CustomEntityResponse:
        """
        创建自定义实体
        
        Args:
            entity_data: 实体数据
            user_id: 用户ID
            
        Returns:
            CustomEntityResponse: 创建的实体
        """
        try:
            entity = await self.dao.create({
                **entity_data.dict(),
                "user_id": user_id
            })
            
            return CustomEntityResponse.from_orm(entity)
        except Exception as e:
            logger.error(f"创建自定义实体失败: {e}")
            raise
    
    async def get_entities(
        self,
        user_id: int,
        entity_type: Optional[str] = None,
        page: int = 1,
        size: int = 10
    ) -> CustomEntityListResponse:
        """
        获取实体列表
        
        Args:
            user_id: 用户ID
            entity_type: 实体类型过滤
            page: 页码
            size: 每页大小
            
        Returns:
            CustomEntityListResponse: 实体列表
        """
        try:
            offset = (page - 1) * size
            
            if entity_type:
                entities = await self.dao.get_by_user_and_type(
                    user_id, entity_type, size, offset
                )
            else:
                entities = await self.dao.get_by_user(
                    user_id, size, offset
                )
            
            total = await self.dao.count_by_user(user_id)
            
            return CustomEntityListResponse(
                entities=[CustomEntityResponse.from_orm(entity) for entity in entities],
                total=total,
                page=page,
                size=size
            )
        except Exception as e:
            logger.error(f"获取自定义实体列表失败: {e}")
            raise
```

### 5. 创建API接口

```python
# app/api/v1/custom.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from app.models.database import get_database
from app.services.custom_service import CustomService
from app.schemas.custom import (
    CustomEntityCreate,
    CustomEntityUpdate,
    CustomEntityResponse,
    CustomEntityListResponse
)

router = APIRouter()

@router.post("/entities", response_model=CustomEntityResponse)
async def create_entity(
    entity_data: CustomEntityCreate,
    user_id: int = Query(..., description="用户ID"),
    db: Session = Depends(get_database)
):
    """
    创建自定义实体
    """
    service = CustomService(db)
    return await service.create_entity(entity_data, user_id)

@router.get("/entities", response_model=CustomEntityListResponse)
async def get_entities(
    user_id: int = Query(..., description="用户ID"),
    entity_type: str = Query(None, description="实体类型"),
    page: int = Query(1, ge=1, description="页码"),
    size: int = Query(10, ge=1, le=100, description="每页大小"),
    db: Session = Depends(get_database)
):
    """
    获取自定义实体列表
    """
    service = CustomService(db)
    return await service.get_entities(user_id, entity_type, page, size)
```

## 测试扩展功能

### 1. 单元测试

```python
# tests/test_custom_extension.py
import pytest
from app.services.custom_service import CustomService
from app.schemas.custom import CustomEntityCreate

@pytest.mark.asyncio
async def test_create_custom_entity():
    """测试创建自定义实体"""
    # 模拟数据库会话
    db = Mock()
    service = CustomService(db)
    
    entity_data = CustomEntityCreate(
        name="测试实体",
        description="这是一个测试实体",
        entity_type="test"
    )
    
    result = await service.create_entity(entity_data, user_id=1)
    
    assert result.name == "测试实体"
    assert result.entity_type == "test"
```

### 2. 集成测试

```python
# tests/integration/test_custom_extension.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_custom_entity_api():
    """测试自定义实体API"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # 创建实体
        response = await client.post("/api/v1/custom/entities", json={
            "name": "测试实体",
            "description": "这是一个测试实体",
            "entity_type": "test"
        }, params={"user_id": 1})
        
        assert response.status_code == 200
        data = response.json()
        assert data["name"] == "测试实体"
        
        # 获取实体列表
        response = await client.get("/api/v1/custom/entities", params={
            "user_id": 1,
            "page": 1,
            "size": 10
        })
        
        assert response.status_code == 200
        data = response.json()
        assert len(data["entities"]) > 0
```

## 部署扩展

### 1. 数据库迁移

```sql
-- migrations/002_add_custom_entities.sql
CREATE TABLE custom_entities (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    entity_type VARCHAR(100) NOT NULL,
    user_id INT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_entity_type (entity_type),
    INDEX idx_name (name),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### 2. 更新依赖

```txt
# requirements.txt
# 现有依赖...

# 新增依赖
psutil>=5.9.0  # 系统信息工具
```

### 3. 配置更新

```yaml
# config/production.yaml
# 现有配置...

# 新增配置
custom_entities:
  max_per_user: 1000
  max_name_length: 255
  allowed_types:
    - "test"
    - "production"
    - "development"
```

## 最佳实践

### 1. 代码组织

- 遵循现有的目录结构
- 使用清晰的命名约定
- 添加适当的文档字符串
- 保持代码简洁和可读

### 2. 错误处理

```python
try:
    # 业务逻辑
    result = await some_operation()
    return result
except SpecificException as e:
    logger.error(f"特定错误: {e}")
    raise HTTPException(status_code=400, detail=str(e))
except Exception as e:
    logger.error(f"未知错误: {e}")
    raise HTTPException(status_code=500, detail="内部服务器错误")
```

### 3. 日志记录

```python
from app.utils.logger import get_logger

logger = get_logger(__name__)

# 记录关键操作
logger.info(f"创建自定义实体: {entity_name}")
logger.warning(f"实体数量接近限制: {current_count}/{max_count}")
logger.error(f"创建实体失败: {error}")
```

### 4. 性能优化

- 使用数据库索引
- 实现分页查询
- 缓存频繁访问的数据
- 异步处理耗时操作

### 5. 安全考虑

- 验证用户输入
- 检查用户权限
- 防止SQL注入
- 限制资源使用

## 总结

本指南介绍了如何扩展Agent智能体系统，包括：

1. **添加新角色**: 创建角色配置、API接口和测试
2. **添加新工具**: 实现工具类、注册和测试
3. **添加新记忆策略**: 创建策略类、注册和配置
4. **添加新路由规则**: 实现规则类、注册和测试
5. **添加新数据模型**: 创建模型、DAO、服务和API
6. **测试和部署**: 单元测试、集成测试和部署配置

通过遵循本指南，您可以轻松扩展系统功能，满足特定需求。
